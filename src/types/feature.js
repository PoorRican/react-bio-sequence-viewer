export function FeatureData(gene, cdregion, prot, rna, pub, bond, site, rsite, user, txinit, num) {
  this.gene = gene;
  this.cdregion = cdregion;
  this.prot = prot;
  this.rna = rna;
  this.pub = pub;
  this.bond = bond;
  this.site = site;
  this.rsite = rsite;
  this.user = user;
  this.txinit = txinit;
  this.num = num;
}

/**
 * Complies with `BioSeqId` specification by NCBI.
 *
 * `features` and `depth` are non-standard attributes used for representation.
 *
 * @param data - NCBI BioSeqId standard data
 * @param data.id {string} - SeqId
 * @param data.data {FeatureData} - NCBI DataAttr content.
 * @param data.location {[number, number]} - Start/end indices
 * @see FeatureData
 *
 * @param data.hierarchy {Feature[]} - Nested `Feature` objects generated by server request
 * @see iterateHierarchy
 */
export class Feature extends Object {
  constructor(data) {
    super(data)

    // NCBI BioSeqId specification
    this.id       = data.id;
    this.data     = data.data;
    this.partial  = data.partial;
    this.except   = data.except;
    this.comment  = data.comment;
    this.product  = data.product;
    this.location = data.location;
    this.qual     = data.qual;
    this.title    = data.title;
    this.ext      = data.ext;
    this.cit      = data.cit;
    this.expEv    = data.expEv;
    this.xref     = data.xref;

    // Non-standard data
    // TODO: these attributes should be separate from object. Implement `RenderFeature` to avoid deviating from specification.
    /**
     * Nested features are `Feature` instances whose `location` occurs within `this.location`.
     * Nesting is computed server-side to improve client performance.
     * @type {Feature[]}
     */
    this.features = data.features;
    this.global_location = data.global_location;
    this.accessor = data.accessor
  }

  get depth() {
    return (this.accessor.match(/::/g) || []).length
  }

  /**
   * Fetch top-level feature in `features`
   * @param id {string} - Accessor key
   * @returns {Feature}
   */
  fetch(id) {
      for (let i of this.features) {
        if (i.id === id) {
          return i;
        }
      }
    }
}

export function generateFeatures(count=15) {
  let features = [];

  for (let i = 0; i < count; i++) {
    let f = {
      id: i.toString(),
      data: null, // simulate data element
      partial: true,
      except: false,
      comment: "this is a comment. There are some words here, but they might not mean anything. Really they're just here to take space...... words...",
      product: 'This is a product. It should really be a link instead of just text...',
      location: i.toString(),
      title: 'Feature #' + i.toString(),
    }
    f = new Feature(f);
    features.push(f)
  }

  return features;
}