export function FeatureData(gene, cdregion, prot, rna, pub, bond, site, rsite, user, txinit, num) {
  this.gene = gene;
  this.cdregion = cdregion;
  this.prot = prot;
  this.rna = rna;
  this.pub = pub;
  this.bond = bond;
  this.site = site;
  this.rsite = rsite;
  this.user = user;
  this.txinit = txinit;
  this.num = num;
}

/**
 * Complies with `BioSeqId` specification by NCBI.
 *
 * Contains non-standard attributes used for internal representation and rendering.
 *
 * Is stored and interacted with via `FeatureContainer`, therefore the object and it's methods are mutable.
 * @see FeatureContainer
 *
 * @param data - NCBI BioSeqId standard data
 * @param data.id {string} - SeqId
 * @param data.data {FeatureData} - NCBI DataAttr content.
 * @param data.location {[number, number]} - Start/end indices
 * @see FeatureData
 *
 * @param data.features {Feature[]} - Nested `Feature` objects generated by server request
 */
export class Feature extends Object {
  constructor(data) {
    super(data)

    // NCBI BioSeqId specification
    this.id       = data.id;
    this.data     = data.data;
    this.partial  = data.partial;
    this.except   = data.except;
    this.comment  = data.comment;
    this.product  = data.product;
    this.location = data.location;
    this.qual     = data.qual;
    this.title    = data.title;
    this.ext      = data.ext;
    this.cit      = data.cit;
    this.expEv    = data.expEv;
    this.xref     = data.xref;

    // Non-standard data
    // TODO: these attributes should be separate from object. Implement `RenderFeature` to avoid deviating from specification.
    /**
     * Nested features are `Feature` instances whose `location` occurs within `this.location`.
     * Nesting is computed server-side to improve client performance.
     *
     * @type {Feature[]}
     */
    this.features = data.features ? data.features : [];
    this.global_location = data.global_location;
    /**
     * Accessor to parent `Feature`
     *
     * @type {string}
     */
    this.parent = data.parent;
    /**
     * Key used to access while in `FeatureContainer`.
     *
     * @type {string}
     *
     * @see FeatureContainer.retrieve
     */
    this.accessor = data.accessor
  }

  get accessor() {
    return ((this.parent && this.parent.length) ? this.parent + '::' : '') + this.id;
  }

  set accessor(value) {
    if (typeof value === 'string') {
      const index = value.lastIndexOf('::');
      if (index > 0) {
        this.parent = value.slice(0, index);
        this.id = value.slice(index+2);
      }
      else {
        this.parent = false;
        this.id = value;
      }
    }
  }

  get parent() {
    return this._parent;
  }

  set parent(value) {
    if (value)
      this._parent = value;
    else
      this._parent = false;

    if (this.features && this.features.length) {
      this.#propagateParentUpdate();
    }
  }

  get depth() {
    return (this.accessor.match(/::/g) || []).length
  }

  /**
   * Propagate changes made to `accessor` onto nested features.
   * @see Feature.parent
   * @see Feature.accessor
   */
  #propagateParentUpdate() {
    this.features.forEach((feature) => {
      feature.parent = this.accessor;
    })
  }

  /**
   * Update accessor during `edit`
   *
   * Update of parent or self portion is dependent on the `parent` flag.
   *
   * @param value {string} - Value to use when updating
   * @param parent=false {boolean} - Update parent segment when `true`
   *
   * @see Feature.edit
   * @deprecated Use accessor setter/getter properties, or `propagateAccessorChange`
   */
  updateAccessor(value, parent=false) {
    const index = this.accessor.lastIndexOf('::');

    if (parent) {
      const end = this.accessor.slice(index + 2);
      /**
       * Do not add delimiter if `value` is empty string
       * @type {string}
       */
      const delimiter = value === "" ? "" : "::"

      this.accessor = value + delimiter + end;
    } else if (index > 0) {
      const parent = this.accessor.slice(0, index);

      this.accessor = parent + '::' + value;
    } else {
      this.accessor = value;
    }

    if (this.features) {
      this.features.forEach((feature) => {
        feature.updateAccessor(this.accessor + value, parent);
      })
    }
  }

  /**
   * Update keys with given values.
   * Also updates `accessor` when `id` is updated.
   *
   * @param kwargs {{}}
   */
  edit(kwargs) {
    for (let [key, val] of Object.entries(kwargs)) {
      this[key] = val;
    }

    // update accessor and nested features
    if (kwargs.id) {
      this.updateAccessor(kwargs.id);

      this.features.forEach((feature) => {
        feature.updateAccessor(this.accessor, true);
      })
    }
  }

  add(feature) {
    if (this.features) {
      this.features.push(feature)
    } else
      this.features = [feature]
  }

  /**
   * Fetch stored feature or index.
   *
   * When `index=false`, `this.filter(() => val.id === id)`
   *
   * @param id {string} - Accessor key delimited by `::`
   * @param index=false {boolean} - Optional flag to return index instead of `Feature`
   *
   * @returns {Feature|number}
   */
  fetch(id, index=false) {
    if (index) {
      for (let i in this.features) {
        if (this.features[i].id === id) {
          return Number(i);
        }
      }
    } else {
      for (let i of this.features) {
        if (i.id === id) {
          return i;
        }
      }
    }
  }

}


/**
 * Generate a list of numbered, identical features.
 *
 * @param count {number} - Number of features to create
 *
 * @returns {Feature[]}
 */
export function generateMultipleFeatures(count=15) {
  let features = [];

  for (let i = 0; i < count; i++) {
    let f = {
      id: i.toString(),
      data: null, // simulate data element
      partial: true,
      except: false,
      comment: "this is a comment. There are some words here, but they might not mean anything. Really they're just here to take space...... words...",
      product: 'This is a product. It should really be a link instead of just text...',
      location: i.toString(),
      title: 'Feature #' + i.toString(),
    }
    f = new Feature(f);
    features.push(f)
  }

  return features;
}